# 数理逻辑

## 说明：

有些符号打不出来，所以使用了近似的符号。

### 命题公式的范式

文字

```javascript
原子命题或者原子命题的反称为文字
```

合取式/析取式

```javascript
文字通过只通过合取联结词/析取联结词组成的命题
```

合取范式/析取范式

```javascript
析取式（合取式）只通过合取联结词（析取联结词）组成的命题
```

### n元联结词

什么是n元联结词，

一个n元联结词可以组织n个变元组成一个命题公式.

**n元命题公式的全体可以划分为2的2^n^次方个等价类**，每一类的公式相互逻辑等价。

每个等价类对应一种n元联结词。该等价类的值的等价于该联结词把这n元组织起来得到的命题公式

```c
证明 n元命题公式的全体可以划分为2^(2^n)个等价类:

n元命题中有n个变元.
对该n个变元，每个变元值只可能是1或者是0。
所以对该n个变元，有2^n种赋值组合，

对于某n元命题公式，对每种组合可能的取值之恶能是1或者0
所以n元命题公式的真值表有 2^(2^n)种

而两个n元命题公式只要他们对于某个变元的赋值组合的真值不同，就可以区分为不同的类
所以n元命题公式可以划分为2^(2^n)个等价类
```

### 常见的四种联结词

|符号|名称|作用|
|-|-|-|
|∧|合取联结词|命题p∧q当且仅当p,q均为1时为1|
|∨|析取联结词|命题p∨q当且仅当p,q均为0时为0|
|→|蕴含联结词|命题p→q当且仅当p为1，且q为0时为0|
|↔|等价联结词|命题p↔q当p,q不同值时为0，同值时为1.|

### 一元联结词

一元联结词与一个命题变元组成命题

1. 常联结词两种：

   命题的真值与其组成变元无关，始终为0或始终为1

2. 幺联结词：

   命题的真值与其组成变元相同

3. 否定词：

   命题的真值与其组成变元相反

![](%E4%B8%80%E5%85%83%E8%81%94%E7%BB%93%E8%AF%8D.png)

### 二元联结词

二元联结词能够把两个命题变元组织成一个命题

下面表格以联结词作用于p,q两个变元为例

|联结词类型|联结词作用（组成命题的值）|
|-|-|
|常联结词两种|组成命题真值与命题无关，恒1或者恒0|
|投影联结词两种|组成命题真值始终等于其两个组成变元中的一个，始终等于p,或始终等于q|
|二元否定词两种|始终为p的反，或q的反|
|或非词（一般记作↓）|¬(p∨q)|
|与非词（一般记为↑）|¬(p∧q)|
|蕴含否定词（两种）|始终为¬(p→q)，或等价于¬(q→p)|
|异或词|¬(p↔q), 也就是说p，q等值的时候为0，p,q不等值的时候为1|
|合取联结词|∧|
|析取联结词|∨|
|蕴含联结词|→|
|等价联结词|↔|

### 联结词的表示与完备词组

1\.联结词的可表示

```javascript
n元联结词h组织p1-pn共n个命题变元组成命题公式A，可记为：
A=h(p1,p2,...,pn)

若存在命题公式B,B由m个联结词g1,g2,...,gm组织（p1,p2,...
,pn)这n个命题变元而成，且A<=>B
则称n元联结词h是由m个联结词g1,g2,...,gm可表示的
```

2\.联结词的完备词组

```javascript
若联结词（g1,g2,...,gm)可表示所有一元、二元联结词，则
称其为完备联结词组

{¬,∧,∨}是完备的联结词组

事实上，完备联结词组可以表示任何n元联结词（会在后面证明）
```

### 常见完备联结词组的证明

证明思路：

```javascript
因为{¬,∧,∨}是完备的联结词组
我们只要证明目标词组能够表达{¬,∧,∨}中的所有联结词，
则目标词组是完备的
```

#### 命题一：{¬,→}是完备联结词组

#### 命题二：{ 恒真常联结词，→}是完备联结词组

#### 命题三：{↓}(或非)是完备联结词组

#### 命题四：{↑}(与非)是完备联结词组

### 证明：任何n元联结词h(p1,p2,...,pn)都可以通过{¬,→}表示

思路：

```javascript
采用数学归纳法
```

### 证明：任何n元联结词都可以通过完备联结词组表示

### 对偶式，内否式和相关定理

## 命题逻辑演算形式系统(Propositional Calculus,PC)

### pc三大公理

公理之后认为是永真式，在pc的证明中可以直接使用，不用证明。公理其实为公理模板，下面的A,B,C表示任意大小和组成的命题。

备注，下面公理的命名为笔者自己的命名

1. (延展)公理：

   ```javascript
   A->(B->A)
   
   (p->q)->(m->(p->q))
   ```

   蕴含式后件为真，蕴含式一定为真

2. (拆分)公理

   ```javascript
   (A->(B->C)) -> (A->B)->(A->C)
   ```

   如果A->(B->C),A->B,A三个条件成立，一定可以推出C成立。

3. (逆否)公理

   ```javascript
   (¬A->¬B) -> (B->A)
   ```

   逆否命题成立，原命题有一定成立，

### 推理规则或分离规则（Modus Ponens)

若A和A->B成立，则必有B成立，也就是（二推一）

### 证明

如果存在这样一个公式序列

```javascript
A1,A2,...,Am(=A)
若对于任意的i属于[1,m],Ai是PC中的公理或是前面的某个公式
或者是前面的某两个用分离规则导出的
```

则称这样的公式序列为A在PC中的一个证明

### 定理

如果公式A在PC中有一个证明，则称序列A是PC中的定理，记为 |-pcA

1. 符号|-表示其后的公式在PC中是可证明的

2. 公理一定是定理

3. 证明序列A1,A2,...,Am中的A1一定是公理（或已知定理）

4. 证明序列A1,A2,...,Am中任何一个都是定理，即|-pcAi, i属于\[1,m\]

### 演绎与演绎结果

***演绎***

设 Γ为PC的公式集合，若对下面的公式序列

```javascript
A1,A2,...,Am(=A)
```

若其中的任意一个公式，要么是 Γ的成员，要么是PC中的公理，要么是前面序列的公式，要么是前面序列的两个公式用分离规则导出的。

则称该公式序列为公式A的一个以Γ为前提在PC中的演绎

***演绎结果***

若命题A有一个以Γ为前提的在PC中的演绎。

则称A为前提Γ在PC中的演绎结果，记为Γ|-pcA

```javascript
特别地：

去掉{}情况：如果Γ={B},则可记为B|-pcA

互相演绎情况：如果B|-pcA并且A|-pcB,则记为A|- -|B

演绎退化为证明: 对Γ为空集，则Γ|-pcA也就是|-pcA

包含必定演绎：若A属于Γ,则必定有Γ|-pcA
```

### 30多条基本定理的证明

用序号对这些基本定理编号

#### 1.定理1： |-pcA->A

```javascript
```

#### 2.定理2（前件互换定理）：如果|-pcA->(B->C)，那么|-pcB->(A->C)

```javascript
```

#### 3.定理3（定理二的变式）：|-（A->(B->C)) ->(B->(A->C)